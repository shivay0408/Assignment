{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "1ae50e7b-ea21-4425-bb42-d39c9f593fd0",
   "metadata": {},
   "outputs": [
    {
     "ename": "IndentationError",
     "evalue": "unexpected indent (3000389659.py, line 6)",
     "output_type": "error",
     "traceback": [
      "\u001b[0;36m  Cell \u001b[0;32mIn[2], line 6\u001b[0;36m\u001b[0m\n\u001b[0;31m    from abc import ABC, abstractmethod\u001b[0m\n\u001b[0m    ^\u001b[0m\n\u001b[0;31mIndentationError\u001b[0m\u001b[0;31m:\u001b[0m unexpected indent\n"
     ]
    }
   ],
   "source": [
    "#Question No. - 01\n",
    "#Ans-\n",
    "    #abstraction in object-oriented programming is the process of hiding the internal implementation details of a class and only exposing the necessary methods or attributes to the outside world. \n",
    "    #This allows users of the class to interact with it without needing to understand how it achieves its functionality internally.\n",
    "    #Example- \n",
    "    from abc import ABC, abstractmethod\n",
    "\n",
    "class Shape(ABC):\n",
    "    # Abstract method\n",
    "    @abstractmethod\n",
    "    def draw(self):\n",
    "        pass\n",
    "\n",
    "class Circle(Shape):\n",
    "   \n",
    "    def draw(self):\n",
    "        print(\"Drawing a circle\")\n",
    "\n",
    "class Rectangle(Shape):\n",
    "    \n",
    "    def draw(self):\n",
    "        print(\"Drawing a rectangle\")\n",
    "\n",
    "circle = Circle()\n",
    "rectangle = Rectangle()\n",
    "\n",
    "\n",
    "circle.draw()     \n",
    "rectangle.draw()  \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "dd1441f9-d3b5-447d-8cb8-c22026026203",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'circle' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[3], line 34\u001b[0m\n\u001b[1;32m     29\u001b[0m         \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mDrawing a rectangle\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[1;32m     32\u001b[0m rectangle \u001b[38;5;241m=\u001b[39m Rectangle()\n\u001b[0;32m---> 34\u001b[0m \u001b[43mcircle\u001b[49m\u001b[38;5;241m.\u001b[39mdraw()     \n\u001b[1;32m     35\u001b[0m rectangle\u001b[38;5;241m.\u001b[39mdraw()  \n\u001b[1;32m     37\u001b[0m \u001b[38;5;66;03m#2.Encapsulation:\u001b[39;00m\n\u001b[1;32m     38\u001b[0m \n\u001b[1;32m     39\u001b[0m \u001b[38;5;66;03m#Encapsulation is the bundling of data and methods that operate on the data into a single unit (class), and restricting access to some of the object's components.\u001b[39;00m\n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m     42\u001b[0m \u001b[38;5;66;03m#Access to the data is typically provided through getter and setter methods, ensuring controlled access to the object's attributes.\u001b[39;00m\n\u001b[1;32m     43\u001b[0m \u001b[38;5;66;03m#Example:\u001b[39;00m\n",
      "\u001b[0;31mNameError\u001b[0m: name 'circle' is not defined"
     ]
    }
   ],
   "source": [
    "#Question No. 02-\n",
    "#Ans.-\n",
    "#Abstraction and encapsulation are two fundamental concepts in object-oriented programming (OOP), but they serve different purposes.\n",
    "#1.Abstraction:\n",
    "\n",
    "#Abstraction is the process of hiding the complex implementation details and showing only the essential features of an object to the outside world.\n",
    "#It focuses on \"what\" an object does rather than \"how\" it does it.\n",
    "#Abstraction is often achieved through abstract classes, interfaces, and abstract methods.\n",
    "#It helps in managing complexity by providing a simplified view of objects.\n",
    "#Example:\n",
    "from abc import ABC, abstractmethod\n",
    "\n",
    "class Shape(ABC):\n",
    "\n",
    "    @abstractmethod\n",
    "    def draw(self):\n",
    "        pass\n",
    "\n",
    "\n",
    "class Circle(Shape):\n",
    "    \n",
    "    def draw(self):\n",
    "        print(\"Drawing a circle\")\n",
    "\n",
    "\n",
    "class Rectangle(Shape):\n",
    "    \n",
    "    def draw(self):\n",
    "        print(\"Drawing a rectangle\")\n",
    "\n",
    "\n",
    "rectangle = Rectangle()\n",
    "\n",
    "circle.draw()     \n",
    "rectangle.draw()  \n",
    "\n",
    "#2.Encapsulation:\n",
    "\n",
    "#Encapsulation is the bundling of data and methods that operate on the data into a single unit (class), and restricting access to some of the object's components.\n",
    "#It helps in data hiding and protecting the internal state of an object from unwanted external access or modification.\n",
    "#Encapsulation allows for better control over the data and prevents unintended interference.\n",
    "#Access to the data is typically provided through getter and setter methods, ensuring controlled access to the object's attributes.\n",
    "#Example:\n",
    "\n",
    "class Car:\n",
    "    def __init__(self, make, model):\n",
    "        self.__make = make    \n",
    "        self.__model = model  \n",
    "\n",
    "    def get_make(self):\n",
    "        return self.__make\n",
    "\n",
    "    def set_make(self, make):\n",
    "        self.__make = make\n",
    "\n",
    "    def get_model(self):\n",
    "        return self.__model\n",
    "\n",
    "    def set_model(self, model):\n",
    "        self.__model = model\n",
    "\n",
    "\n",
    "car = Car(\"Toyota\", \"Camry\")\n",
    "\n",
    "print(car.get_make())  \n",
    "car.set_make(\"Honda\")\n",
    "print(car.get_make())  \n",
    "\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "30993020-23ee-48b3-89cd-7ad894e44401",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Woof!\n",
      "Meow!\n"
     ]
    }
   ],
   "source": [
    "#Question NO. 03-\n",
    "#Ans.-\n",
    "#The abc module in Python stands for \"Abstract Base Classes.\" \n",
    "#It provides a way to define abstract base classes in Python. \n",
    "#Abstract base classes are classes that cannot be instantiated directly but are designed to be subclassed by other classes, which must implement the abstract methods defined in the base class.\n",
    "\n",
    "#he abc module is used for several purposes:\n",
    "\n",
    "#1.Defining Abstract Base Classes (ABCs):\n",
    "#The abc module provides the ABC class, which can be subclassed to create abstract base classes. Abstract methods within these classes are defined using the @abstractmethod decorator. Subclasses of these abstract base classes must implement all the abstract methods, ensuring a consistent interface across different implementations.\n",
    "\n",
    "#2.Enforcing Interface Contracts:\n",
    "#By defining abstract base classes, the abc module allows you to define a common interface that subclasses must adhere to. This helps in enforcing a contract between different parts of a program, ensuring that certain methods or behaviors are implemented consistently across different classes.\n",
    "\n",
    "#3.Polymorphism:\n",
    "#Abstract base classes facilitate polymorphism in Python. Since different subclasses of an abstract base class can implement the abstract methods differently, objects of these subclasses can be used interchangeably where the abstract base class is expected, enabling polymorphic behavior.\n",
    "\n",
    "#4.Documentation and Readability:\n",
    "#Using abstract base classes can improve the readability and maintainability of code by clearly indicating the expected interface of a class and the methods that subclasses should implement.\n",
    "\n",
    "#Here's a simple example demonstrating the usage of the abc module to define an abstract base class:\n",
    "\n",
    "from abc import ABC, abstractmethod\n",
    "\n",
    "class Animal(ABC):\n",
    "    @abstractmethod\n",
    "    def speak(self):\n",
    "        pass\n",
    "\n",
    "class Dog(Animal):\n",
    "    def speak(self):\n",
    "        return \"Woof!\"\n",
    "\n",
    "class Cat(Animal):\n",
    "    def speak(self):\n",
    "        return \"Meow!\"\n",
    "\n",
    "dog = Dog()\n",
    "cat = Cat()\n",
    "\n",
    "print(dog.speak())  \n",
    "print(cat.speak()) \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "161e2e86-8eba-488b-afe0-886c8e2dd31e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Current balance: 1000\n",
      "Updated balance: 1300\n"
     ]
    }
   ],
   "source": [
    "#Question No.04-\n",
    "#Ans.-\n",
    "#Data abstraction in programming involves hiding the complex implementation details of data and showing only the essential features to users. In object-oriented programming, it's achieved by:\n",
    "\n",
    "#Using classes and objects to encapsulate data and behavior.\n",
    "#Employing access modifiers to control access to attributes and methods.\n",
    "#Defining abstract classes or interfaces to provide blueprints for classes.\n",
    "#Using getter and setter methods for controlled access to private attributes.\n",
    "#Encapsulating data and methods within classes.\n",
    "#Leveraging polymorphism for uniform treatment of objects through a common interface.\n",
    "#These practices simplify the interaction with data, enhance code readability, and facilitate maintenance.\n",
    "\n",
    "#Here's a simple example in Python demonstrating data abstraction using classes and encapsulation:\n",
    "\n",
    "class BankAccount:\n",
    "    def __init__(self, account_number, balance):\n",
    "        self.__account_number = account_number  \n",
    "        self.__balance = balance                \n",
    "\n",
    "    def deposit(self, amount):\n",
    "        self.__balance += amount\n",
    "\n",
    "    def withdraw(self, amount):\n",
    "        if amount <= self.__balance:\n",
    "            self.__balance -= amount\n",
    "        else:\n",
    "            print(\"Insufficient funds\")\n",
    "\n",
    "    def get_balance(self):\n",
    "        return self.__balance\n",
    "\n",
    "account = BankAccount(\"123456789\", 1000)\n",
    "\n",
    "print(\"Current balance:\", account.get_balance())\n",
    "\n",
    "account.deposit(500)\n",
    "account.withdraw(200)\n",
    "\n",
    "print(\"Updated balance:\", account.get_balance())\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4431edf1-1282-441a-b1be-4cc2daf8299f",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Question No. 05-\n",
    "#Ans.-\n",
    " #Abstract classes are designed to serve as blueprints for other classes and typically contain one or more abstract methods that lack implementation. These abstract methods must be implemented by concrete subclasses.\n",
    " #As a result, attempting to instantiate an abstract class directly would be nonsensical because it would result in an object that cannot fulfill the contract defined by the abstract methods.\n",
    "\n",
    "\n",
    "from abc import ABC, abstractmethod\n",
    "\n",
    "class AbstractClass(ABC):\n",
    "    @abstractmethod\n",
    "    def abstract_method(self):\n",
    "        pass\n",
    "\n",
    "# Attempting to create an instance of the abstract class\n",
    "instance = AbstractClass()  # This will raise a TypeError\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
